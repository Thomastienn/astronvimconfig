{

        "dsu": {
            "prefix": ["dsu"],
            "body": [
                "class DSU:",
				"    def __init__(self, n):",
				"        self.parent = list(range(n))",
				"        self.size = [1] * n",
				"",
				"    def find(self, x):",
				"        while self.parent[x] != x:",
				"            self.parent[x] = self.parent[self.parent[x]]  # Path compression",
				"            x = self.parent[x]",
				"        return x",
				"",
				"    def union(self, x, y):",
				"        xroot = self.find(x)",
				"        yroot = self.find(y)",
				"        if xroot == yroot:",
				"            return False",
				"        if self.size[xroot] < self.size[yroot]:",
				"            xroot, yroot = yroot, xroot",
				"        self.parent[yroot] = xroot",
				"        self.size[xroot] += self.size[yroot]",
				"        return True"

            ],
            "description": "Desciption"
        }
    ,
        "trie": {
            "prefix": ["trie"],
            "body": [
                "class TrieNode:",
				"    def __init__(self):",
				"        self.children = {}",
				"        self.is_end = False",
				"class Trie:",
				"    def __init__(self):",
				"        self.root = TrieNode()",
				"    def insert(self, word):",
				"        node = self.root",
				"        for char in word:",
				"            if char not in node.children:",
				"                node.children[char] = TrieNode()",
				"            node = node.children[char]",
				"        node.is_end = True",
				"    def search(self, word):",
				"        node = self.root",
				"        for char in word:",
				"            if char not in node.children:",
				"                return False",
				"            node = node.children[char]",
				"        return node.is_end",
				"    def starts_with(self, prefix):",
				"        node = self.root",
				"        for char in prefix:",
				"            if char not in node.children:",
				"                return False",
				"            node = node.children[char]",
				"        return True"

            ],
            "description": "Desciption"
        }
    ,
        "ternary": {
            "prefix": ["ternary"],
            "body": [
                "def f(x):",
				"    return (x+2)**2-5",
				"",
				"def ternary_search(l, r):",
				"    eps = 10**(-6)",
				"    while r-l > eps:",
				"        m1 = l+(r-l)/3",
				"        m2 = r-(r-l)/3",
				"        ",
				"        f1 = f(m1)",
				"        f2 = f(m2)",
				"        if f1 < f2:",
				"            r = m2",
				"        else:",
				"            l = m1",
				"    ",
				"    return round(f(l)), round(l)",
				"",
				"print(ternary_search(-10, 10))"

            ],
            "description": "Desciption"
        }
    ,
        "sieve": {
            "prefix": ["sieve"],
            "body": [
                "def sieve(n):",
				"    is_prime = [True] * (n + 1)",
				"    is_prime[0] = is_prime[1] = False",
				"    for p in range(2, int(n**0.5) + 1):",
				"        if is_prime[p]:",
				"            for multiple in range(p * p, n + 1, p):",
				"                is_prime[multiple] = False",
				"    primes = [p for p, prime in enumerate(is_prime) if prime]",
				"    return primes"

            ],
            "description": "Desciption"
        }
    ,
        "topo": {
            "prefix": ["topo"],
            "body": [
                "def topological_sort(n, adj):",
				"    from collections import deque",
				"    ",
				"    in_degree = [0] * n",
				"    for u in range(n):",
				"        for v in adj[u]:",
				"            in_degree[v] += 1",
				"    ",
				"    queue = deque([i for i in range(n) if in_degree[i] == 0])",
				"    topo_order = []",
				"    ",
				"    while queue:",
				"        u = queue.popleft()",
				"        topo_order.append(u)",
				"        for v in adj[u]:",
				"            in_degree[v] -= 1",
				"            if in_degree[v] == 0:",
				"                queue.append(v)",
				"    ",
				"    return topo_order"

            ],
            "description": "Desciption"
        }
    ,
        "kruskal": {
            "prefix": ["kruskal"],
            "body": [
                "def kruskal_mst(n, edges):",
				"    dsu = DSU(n) # type: ignore # noqa",
				"    ",
				"    # Sort edges by weight",
				"    edges.sort(key=lambda x: x[2])",
				"    ",
				"    total_weight = 0",
				"    mst_edges = []",
				"    ",
				"    for u, v, weight in edges:",
				"        if dsu.find(u) != dsu.find(v):",
				"            dsu.union(u, v)",
				"            total_weight += weight",
				"            mst_edges.append((u, v, weight))",
				"            if len(mst_edges) == n - 1:",
				"                break",
				"    ",
				"    return total_weight, mst_edges"

            ],
            "description": "Desciption"
        }
    ,
        "tem": {
            "prefix": ["tem"],
            "body": [
                "import sys",
				"import math",
				"import heapq",
				"import bisect",
				"import re",
				"from sys import stdin,stdout",
				"from math import gcd,floor,sqrt,log",
				"from collections import defaultdict, Counter, deque, OrderedDict",
				"from bisect import bisect_left, bisect_right",
				"from itertools import permutations, combinations",
				"",
				"sys.setrecursionlimit(10**6)",
				"mod=1000000007",
				"",
				"infile = sys.argv[1] if len(sys.argv) >= 2 else \"1.in\"",
				"f = open(infile).read().strip()",
				"    ",
				"for line in f.split(\"\\n\"):",
				"    pass"

            ],
            "description": "Desciption"
        }
    ,
        "rollhash": {
            "prefix": ["rollhash"],
            "body": [
                "class RollingHash:",
				"    def __init__(self, s, base=911382629, mod=10**18 + 3):",
				"        self.s = s",
				"        self.n = len(s)",
				"        self.base = base",
				"        self.mod = mod",
				"        self.powers = [1] * (self.n + 1)",
				"        self.prefix_hashes = [0] * (self.n + 1)",
				"        for i in range(1, self.n + 1):",
				"            self.powers[i] = (self.powers[i - 1] * self.base) % self.mod",
				"        for i in range(1, self.n + 1):",
				"            self.prefix_hashes[i] = (self.prefix_hashes[i - 1] * self.base + ord(s[i - 1])) % self.mod",
				"    def get_hash(self, l, r):",
				"        return (self.prefix_hashes[r] - self.prefix_hashes[l] * self.powers[r - l]) % self.mod"

            ],
            "description": "Desciption"
        }
    ,
        "sparse": {
            "prefix": ["sparse"],
            "body": [
                "class SparseTable:",
				"    def __init__(self, array, func=min):",
				"        self.n = len(array)",
				"        self.func = func",
				"        self.k = self.n.bit_length()",
				"        self.st = [[0] * self.n for _ in range(self.k)]",
				"        self.st[0] = array.copy()",
				"        for i in range(1, self.k):",
				"            j = 0",
				"            while j + (1 << i) <= self.n:",
				"                self.st[i][j] = self.func(self.st[i - 1][j], self.st[i - 1][j + (1 << (i - 1))])",
				"                j += 1",
				"",
				"    def query(self, l, r):",
				"        i = (r - l + 1).bit_length() - 1",
				"        return self.func(self.st[i][l], self.st[i][r - (1 << i) + 1])"

            ],
            "description": "Desciption"
        }
    ,
        "cycledir": {
            "prefix": ["cycledir"],
            "body": [
                "def has_cycle_directed(n, adj):",
				"    WHITE, GRAY, BLACK = 0, 1, 2",
				"    color = [WHITE] * n",
				"    ",
				"    def dfs(u):",
				"        color[u] = GRAY",
				"        for v in adj[u]:",
				"            if color[v] == GRAY:  # Back edge = cycle",
				"                return True",
				"            if color[v] == WHITE and dfs(v):",
				"                return True",
				"        color[u] = BLACK",
				"        return False",
				"    ",
				"    for i in range(n):",
				"        if color[i] == WHITE:",
				"            if dfs(i):",
				"                return True",
				"    return False"

            ],
            "description": "Desciption"
        }
    ,
        "ssegt": {
            "prefix": ["ssegt"],
            "body": [
                "tree = [0] * (2 * n)",
				"def query(x, x_low, x_high, q_low, q_high):",
				"    if q_low <= x_low and x_high <= q_high:",
				"        return tree[x]",
				"    if x_high < q_low or q_high < x_low:",
				"        return 0",
				"    mid = (x_low + x_high) // 2",
				"    left = query(x*2, x_low, mid, q_low, q_high)",
				"    right = query(x*2+1, mid+1, x_high, q_low, q_high)",
				"",
				"    return left + right",
				"def update(i, v):",
				"    tree[n+i] = v;",
				"    j = (n + i) // 2",
				"    while j >= 1:",
				"        tree[j] = tree[j*2] + tree[j*2+1]",
				"        j //= 2",
				"    ",
				"for i in range(n):",
				"    tree[n+i] = a[i]",
				"",
				"for i in range(n-1, 0, -1):",
				"    tree[i] = tree[i*2] + tree[i*2+1]"

            ],
            "description": "Desciption"
        }
    ,
        "cycleundir": {
            "prefix": ["cycleundir"],
            "body": [
                "def has_cycle_undirected(n, adj):",
				"    visited = [False] * n",
				"    ",
				"    def dfs(u, parent):",
				"        visited[u] = True",
				"        for v in adj[u]:",
				"            if not visited[v]:",
				"                if dfs(v, u):",
				"                    return True",
				"            elif v != parent:  # Visited and not parent = cycle",
				"                return True",
				"        return False",
				"    ",
				"    for i in range(n):",
				"        if not visited[i]:",
				"            if dfs(i, -1):",
				"                return True",
				"    return False"

            ],
            "description": "Desciption"
        }
    ,
        "prim": {
            "prefix": ["prim"],
            "body": [
                "def prim_mst(n, adj):",
				"    import heapq",
				"    ",
				"    visited = [False] * n",
				"    min_heap = [(0, 0, -1)]  # (weight, node, parent)",
				"    total_weight = 0",
				"    edges = []",
				"    ",
				"    while min_heap:",
				"        weight, u, parent = heapq.heappop(min_heap)",
				"        ",
				"        if visited[u]:",
				"            continue",
				"        ",
				"        visited[u] = True",
				"        total_weight += weight",
				"        ",
				"        if parent != -1:",
				"            edges.append((parent, u, weight))",
				"        ",
				"        for v, w in adj[u]:",
				"            if not visited[v]:",
				"                heapq.heappush(min_heap, (w, v, u))",
				"    ",
				"    return total_weight, edges"

            ],
            "description": "Desciption"
        }
    ,
        "segt": {
            "prefix": ["segt"],
            "body": [
                "from math import ceil, log2",
				"class segment_tree:",
				"    # merge(left, right): function used to merge the two halves",
				"    # basef(value): function applied on individual values",
				"    # basev: identity for merge function, merger(value, basev) = value",
				"    # update(node_value, old, new): function to update the nodes",
				"    def __init__(self, array, merge=lambda x,y:x+y, basef=lambda x:x, basev = 0):",
				"        self.merge = merge",
				"        self.basef = basef",
				"        self.basev = basev",
				"        self.n = len(array)",
				"        self.array = array",
				"        self.tree = [0] * ( 2**ceil(log2(len(array))+1) - 1 )",
				"        self.build(array)",
				"    def __str__(self):",
				"        return ' '.join([str(x) for x in self.tree])",
				"    def _build_util(self, l, r, i, a):",
				"        if(l==r):",
				"            self.tree[i] = self.basef(a[l])",
				"            return self.tree[i]",
				"        mid = (l+r)//2",
				"        self.tree[i] = self.merge(self._build_util(l,mid, 2*i+1, a), self._build_util(mid+1, r, 2*i+2, a))",
				"        return self.tree[i]",
				"    def build(self, a):",
				"        self._build_util(0, len(a)-1, 0, a)",
				"    def _query_util(self, i, ln, rn, l, r):",
				"        if ln>=l and rn<=r:",
				"            return self.tree[i]",
				"        if ln>r or rn<l:",
				"            return self.basev",
				"        return self.merge( self._query_util( 2*i+1, ln, (ln+rn)//2, l, r ), self._query_util( 2*i+2, (ln+rn)//2+1, rn, l, r ) )",
				"    def query(self, l, r):",
				"        return self._query_util( 0, 0, self.n-1, l, r )",
				"    def _update_util(self, i, ln, rn, x, v):",
				"        if x>=ln and x<=rn:",
				"            if ln != rn:",
				"                self._update_util( 2*i+1, ln, (ln+rn)//2, x, v )",
				"                self._update_util( 2*i+2, (ln+rn)//2 + 1, rn, x, v )",
				"                self.tree[i] = self.merge(self.tree[2*i+1], self.tree[2*i+2])",
				"            else:",
				"                self.tree[i] = self.basef(v)",
				"    def update(self, x, v):",
				"        self._update_util( 0, 0, self.n-1, x, v )   ",
				"        self.array[x] =v"

            ],
            "description": "Desciption"
        }
    ,
        "bit": {
            "prefix": ["bit"],
            "body": [
                "class FenwickTree:",
				"    def __init__(self, size):",
				"        self.n = size",
				"        self.tree = [0] * (self.n + 1)",
				"",
				"    def update(self, idx, delta):",
				"        while idx <= self.n:",
				"            self.tree[idx] += delta",
				"            idx += idx & -idx",
				"",
				"    def query(self, idx):",
				"        res = 0",
				"        while idx > 0:",
				"            res += self.tree[idx]",
				"            idx -= idx & -idx",
				"        return res",
				"",
				"    def range_query(self, l, r):",
				"        return self.query(r) - self.query(l)"

            ],
            "description": "Desciption"
        }
    ,
        "kosaraju": {
            "prefix": ["kosaraju"],
            "body": [
                "def kosaraju_scc(n, adj):",
				"    # Build reverse graph",
				"    rev_adj = [[] for _ in range(n)]",
				"    for u in range(n):",
				"        for v in adj[u]:",
				"            rev_adj[v].append(u)",
				"    ",
				"    # First DFS to get finish order",
				"    visited = [False] * n",
				"    order = []",
				"    ",
				"    def dfs1(u):",
				"        visited[u] = True",
				"        for v in adj[u]:",
				"            if not visited[v]:",
				"                dfs1(v)",
				"        order.append(u)",
				"    ",
				"    for i in range(n):",
				"        if not visited[i]:",
				"            dfs1(i)",
				"    ",
				"    # Second DFS on reverse graph in reverse finish order",
				"    visited = [False] * n",
				"    sccs = []",
				"    ",
				"    def dfs2(u, scc):",
				"        visited[u] = True",
				"        scc.append(u)",
				"        for v in rev_adj[u]:",
				"            if not visited[v]:",
				"                dfs2(v, scc)",
				"    ",
				"    for u in reversed(order):",
				"        if not visited[u]:",
				"            scc = []",
				"            dfs2(u, scc)",
				"            sccs.append(scc)",
				"    ",
				"    return sccs"

            ],
            "description": "Desciption"
        }
    ,
        "tarjan": {
            "prefix": ["tarjan"],
            "body": [
                "def tarjan_scc(n, adj) -> list[list[int]]:",
				"    disc = [-1] * n",
				"    low = [-1] * n",
				"    on_stack = [False] * n",
				"    stack = []",
				"    time = [0]",
				"    sccs = []",
				"    ",
				"    def dfs(u):",
				"        disc[u] = low[u] = time[0]",
				"        time[0] += 1",
				"        stack.append(u)",
				"        on_stack[u] = True",
				"        ",
				"        for v in adj[u]:",
				"            if disc[v] == -1:",
				"                dfs(v)",
				"                low[u] = min(low[u], low[v])",
				"            elif on_stack[v]:",
				"                low[u] = min(low[u], disc[v])",
				"        ",
				"        if low[u] == disc[u]:",
				"            scc = []",
				"            while True:",
				"                node = stack.pop()",
				"                on_stack[node] = False",
				"                scc.append(node)",
				"                if node == u:",
				"                    break",
				"            sccs.append(scc)",
				"    ",
				"    for i in range(n):",
				"        if disc[i] == -1:",
				"            dfs(i)",
				"    ",
				"    return sccs"

            ],
            "description": "Desciption"
        }
    ,
        "ncr": {
            "prefix": ["ncr"],
            "body": [
                "fact = [1] * (MAXN + 1)",
				"inv = [1] * (MAXN + 1)",
				"for i in range(2, MAXN + 1):",
				"    fact[i] = fact[i - 1] * i % MOD",
				"inv[MAXN] = pow(fact[MAXN], MOD - 2, MOD)  ",
				"for i in range(MAXN - 1, 0, -1):",
				"    inv[i] = inv[i + 1] * (i + 1) % MOD",
				"def nCr(n, r):",
				"    if r > n or r < 0:",
				"        return 0",
				"    return fact[n] * inv[r] % MOD * inv[n - r] % MOD"

            ],
            "description": "Desciption"
        }
    
}
