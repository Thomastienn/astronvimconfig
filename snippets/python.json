{

        "dsu": {
            "prefix": ["dsu"],
            "body": [
                "class DSU:",
				"    def __init__(self, n):",
				"        self.parent = list(range(n))",
				"        self.size = [1] * n",
				"",
				"    def find(self, x):",
				"        while self.parent[x] != x:",
				"            self.parent[x] = self.parent[self.parent[x]]  # Path compression",
				"            x = self.parent[x]",
				"        return x",
				"",
				"    def union(self, x, y):",
				"        xroot = self.find(x)",
				"        yroot = self.find(y)",
				"        if xroot == yroot:",
				"            return False",
				"        if self.size[xroot] < self.size[yroot]:",
				"            xroot, yroot = yroot, xroot",
				"        self.parent[yroot] = xroot",
				"        self.size[xroot] += self.size[yroot]",
				"        return True",
				"",
				"    def same(self, x, y):",
				"        return self.find(x) == self.find(y)"

            ],
            "description": "Desciption"
        }
    ,
        "ternary": {
            "prefix": ["ternary"],
            "body": [
                "def f(x):",
				"    return (x+2)**2-5",
				"",
				"def ternary_search(l, r):",
				"    eps = 10**(-6)",
				"    while r-l > eps:",
				"        m1 = l+(r-l)/3",
				"        m2 = r-(r-l)/3",
				"        ",
				"        f1 = f(m1)",
				"        f2 = f(m2)",
				"        if f1 < f2:",
				"            r = m2",
				"        else:",
				"            l = m1",
				"    ",
				"    return round(f(l)), round(l)",
				"",
				"print(ternary_search(-10, 10))"

            ],
            "description": "Desciption"
        }
    ,
        "cp": {
            "prefix": ["cp"],
            "body": [
                "import sys",
				"input = sys.stdin.readline",
				"",
				"def inp():",
				"    return(int(input()))",
				"def inl():",
				"    return(list(map(int,input().split())))",
				"def ins():",
				"    s = input()",
				"    return(list(s[:len(s) - 1]))",
				"def inv():",
				"    return(map(int,input().split()))",
				"",
				"def solve():",
				"    ...",
				"",
				"t = inp()",
				"for _ in range(t):",
				"    solve()"

            ],
            "description": "Desciption"
        }
    ,
        "tem": {
            "prefix": ["tem"],
            "body": [
                "import sys",
				"import math",
				"import heapq",
				"import bisect",
				"import re",
				"from sys import stdin,stdout",
				"from math import gcd,floor,sqrt,log",
				"from collections import defaultdict, Counter, deque, OrderedDict",
				"from bisect import bisect_left, bisect_right",
				"from itertools import permutations, combinations",
				"",
				"sys.setrecursionlimit(10**6)",
				"mod=1000000007",
				"",
				"infile = sys.argv[1] if len(sys.argv) >= 2 else \"1.in\"",
				"f = open(infile).read().strip()",
				"    ",
				"for line in f.split(\"\\n\"):",
				"    pass"

            ],
            "description": "Desciption"
        }
    ,
        "rollhash": {
            "prefix": ["rollhash"],
            "body": [
                "class RollingHash:",
				"    def __init__(self, s, base=911382629, mod=10**18 + 3):",
				"        self.s = s",
				"        self.n = len(s)",
				"        self.base = base",
				"        self.mod = mod",
				"        self.powers = [1] * (self.n + 1)",
				"        self.prefix_hashes = [0] * (self.n + 1)",
				"        for i in range(1, self.n + 1):",
				"            self.powers[i] = (self.powers[i - 1] * self.base) % self.mod",
				"        for i in range(1, self.n + 1):",
				"            self.prefix_hashes[i] = (self.prefix_hashes[i - 1] * self.base + ord(s[i - 1])) % self.mod",
				"    def get_hash(self, l, r):",
				"        return (self.prefix_hashes[r] - self.prefix_hashes[l] * self.powers[r - l]) % self.mod"

            ],
            "description": "Desciption"
        }
    ,
        "cht": {
            "prefix": ["cht"],
            "body": [
                "from collections import deque",
				"",
				"class CHT:",
				"    \"\"\"",
				"    Convex Hull Trick for DP optimization",
				"    Maintains lines y = mx + b, answers min queries",
				"    ",
				"    Requirements:",
				"    - Lines added in decreasing order of slope (m)",
				"    - Queries in increasing order of x",
				"    ",
				"    Time: O(1) amortized per operation",
				"    ",
				"    Use case: dp[i] = min(dp[j] + cost(j,i)) where cost(j,i) = m[j] * x[i] + b[j]",
				"    \"\"\"",
				"    def __init__(self):",
				"        self.lines = deque()  # (m, b)",
				"    ",
				"    def _bad(self, l1, l2, l3) -> bool:",
				"        \"\"\"Check if l2 is useless (dominated by l1 and l3)\"\"\"",
				"        # (b1-b2)/(m2-m1) >= (b2-b3)/(m3-m2)",
				"        # Cross multiply to avoid division",
				"        return (l1[1] - l2[1]) * (l3[0] - l2[0]) >= (l2[1] - l3[1]) * (l2[0] - l1[0])",
				"    ",
				"    def add(self, m: int, b: int) -> None:",
				"        \"\"\"Add line y = mx + b (must add in decreasing order of m)\"\"\"",
				"        line = (m, b)",
				"        while len(self.lines) >= 2 and self._bad(self.lines[-2], self.lines[-1], line):",
				"            self.lines.pop()",
				"        self.lines.append(line)",
				"    ",
				"    def query(self, x: int) -> int:",
				"        \"\"\"Query minimum y at x (must query in increasing order of x)\"\"\"",
				"        while len(self.lines) >= 2:",
				"            m1, b1 = self.lines[0]",
				"            m2, b2 = self.lines[1]",
				"            if m1 * x + b1 >= m2 * x + b2:",
				"                self.lines.popleft()",
				"            else:",
				"                break",
				"        m, b = self.lines[0]",
				"        return m * x + b"

            ],
            "description": "Desciption"
        }
    ,
        "sieve": {
            "prefix": ["sieve"],
            "body": [
                "def sieve(n):",
				"    is_prime = [True] * (n + 1)",
				"    is_prime[0] = is_prime[1] = False",
				"    for p in range(2, int(n**0.5) + 1):",
				"        if is_prime[p]:",
				"            for multiple in range(p * p, n + 1, p):",
				"                is_prime[multiple] = False",
				"    primes = [p for p, prime in enumerate(is_prime) if prime]",
				"    return primes"

            ],
            "description": "Desciption"
        }
    ,
        "extgcd": {
            "prefix": ["extgcd"],
            "body": [
                "def extgcd(a: int, b: int) -> tuple[int, int, int]:",
				"    \"\"\"Returns (gcd, x, y) where ax + by = gcd\"\"\"",
				"    if b == 0:",
				"        return a, 1, 0",
				"    g, x, y = extgcd(b, a % b)",
				"    return g, y, x - (a // b) * y",
				"",
				"def mod_inv_general(a: int, mod: int) -> int:",
				"    \"\"\"Works for any mod if gcd(a, mod) = 1\"\"\"",
				"    g, x, _ = extgcd(a, mod)",
				"    return x % mod if g == 1 else -1"

            ],
            "description": "Desciption"
        }
    ,
        "millerrabin": {
            "prefix": ["millerrabin"],
            "body": [
                "def miller_rabin(n: int) -> bool:",
				"    \"\"\"",
				"    Deterministic primality test for n < 3,317,044,064,679,887,385,961,981",
				"    Time: O(k log^3 n) where k = number of witnesses",
				"    \"\"\"",
				"    if n < 2:",
				"        return False",
				"    if n == 2 or n == 3:",
				"        return True",
				"    if n % 2 == 0:",
				"        return False",
				"    ",
				"    # Write n-1 as 2^r * d",
				"    r, d = 0, n - 1",
				"    while d % 2 == 0:",
				"        r += 1",
				"        d //= 2",
				"    ",
				"    # Witnesses that work for all n < 3,317,044,064,679,887,385,961,981",
				"    witnesses = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]",
				"    ",
				"    for a in witnesses:",
				"        if a >= n:",
				"            continue",
				"        ",
				"        x = pow(a, d, n)",
				"        ",
				"        if x == 1 or x == n - 1:",
				"            continue",
				"        ",
				"        for _ in range(r - 1):",
				"            x = x * x % n",
				"            if x == n - 1:",
				"                break",
				"        else:",
				"            return False",
				"    ",
				"    return True"

            ],
            "description": "Desciption"
        }
    ,
        "fft": {
            "prefix": ["fft"],
            "body": [
                "import cmath",
				"from typing import List",
				"",
				"def fft(a: List[complex], invert: bool = False) -> List[complex]:",
				"    \"\"\"",
				"    Fast Fourier Transform (in-place)",
				"    Time: O(n log n)",
				"    \"\"\"",
				"    n = len(a)",
				"    if n == 1:",
				"        return a",
				"    ",
				"    # Bit-reversal permutation",
				"    j = 0",
				"    for i in range(1, n):",
				"        bit = n >> 1",
				"        while j & bit:",
				"            j ^= bit",
				"            bit >>= 1",
				"        j ^= bit",
				"        if i < j:",
				"            a[i], a[j] = a[j], a[i]",
				"    ",
				"    # Cooley-Tukey FFT",
				"    length = 2",
				"    while length <= n:",
				"        angle = 2 * cmath.pi / length * (-1 if invert else 1)",
				"        wn = cmath.exp(1j * angle)",
				"        ",
				"        for i in range(0, n, length):",
				"            w = 1",
				"            for k in range(length // 2):",
				"                u = a[i + k]",
				"                v = a[i + k + length // 2] * w",
				"                a[i + k] = u + v",
				"                a[i + k + length // 2] = u - v",
				"                w *= wn",
				"        length *= 2",
				"    ",
				"    if invert:",
				"        for i in range(n):",
				"            a[i] /= n",
				"    ",
				"    return a"

            ],
            "description": "Desciption"
        }
    ,
        "crt": {
            "prefix": ["crt"],
            "body": [
                "def crt(remainders: list[int], mods: list[int]) -> tuple[int, int]:",
				"    \"\"\"",
				"    Find x such that x â‰¡ r[i] (mod m[i])",
				"    Returns (x, lcm) or (-1, -1) if no solution",
				"    \"\"\"",
				"    x, m = 0, 1",
				"    for ri, mi in zip(remainders, mods):",
				"        g, a, _ = extgcd(m, mi)",
				"        if (ri - x) % g != 0:",
				"            return -1, -1",
				"        x = x + m * ((ri - x) // g * a % (mi // g))",
				"        m = m // g * mi",
				"        x %= m",
				"    return x, m"

            ],
            "description": "Desciption"
        }
    ,
        "matrix": {
            "prefix": ["matrix"],
            "body": [
                "class Matrix:",
				"    \"\"\"",
				"    Matrix operations with modular arithmetic",
				"    - Multiply: O(n^3)",
				"    - Power: O(n^3 log k)",
				"    ",
				"    Use cases: Linear recurrences, counting paths, DP optimization",
				"    \"\"\"",
				"    def __init__(self, mat: list[list[int]], mod: int = 10**9 + 7):",
				"        self.mat = mat",
				"        self.n = len(mat)",
				"        self.m = len(mat[0]) if mat else 0",
				"        self.mod = mod",
				"    ",
				"    def __mul__(self, other: 'Matrix') -> 'Matrix':",
				"        assert self.m == other.n",
				"        result = [[0] * other.m for _ in range(self.n)]",
				"        for i in range(self.n):",
				"            for k in range(self.m):",
				"                if self.mat[i][k] == 0:",
				"                    continue",
				"                for j in range(other.m):",
				"                    result[i][j] = (result[i][j] + self.mat[i][k] * other.mat[k][j]) % self.mod",
				"        return Matrix(result, self.mod)",
				"    ",
				"    def __pow__(self, k: int) -> 'Matrix':",
				"        assert self.n == self.m  # Must be square",
				"        result = Matrix.identity(self.n, self.mod)",
				"        base = Matrix([row[:] for row in self.mat], self.mod)",
				"        while k:",
				"            if k & 1:",
				"                result = result * base",
				"            base = base * base",
				"            k >>= 1",
				"        return result",
				"    ",
				"    @staticmethod",
				"    def identity(n: int, mod: int = 10**9 + 7) -> 'Matrix':",
				"        mat = [[1 if i == j else 0 for j in range(n)] for i in range(n)]",
				"        return Matrix(mat, mod)",
				"    ",
				"    def __repr__(self):",
				"        return '\\n'.join(str(row) for row in self.mat)"

            ],
            "description": "Desciption"
        }
    ,
        "modmath": {
            "prefix": ["modmath"],
            "body": [
                "def mod_add(a: int, b: int, mod: int = MOD) -> int:",
				"    return (a + b) % mod",
				"",
				"def mod_sub(a: int, b: int, mod: int = MOD) -> int:",
				"    return (a - b + mod) % mod",
				"",
				"def mod_mul(a: int, b: int, mod: int = MOD) -> int:",
				"    return (a * b) % mod",
				"",
				"def mod_pow(base: int, exp: int, mod: int = MOD) -> int:",
				"    result = 1",
				"    base %= mod",
				"    while exp > 0:",
				"        if exp & 1:",
				"            result = result * base % mod",
				"        exp >>= 1",
				"        base = base * base % mod",
				"    return result",
				"",
				"def mod_inv(a: int, mod: int = MOD) -> int:",
				"    \"\"\"Mod must be prime\"\"\"",
				"    return mod_pow(a, mod - 2, mod)"

            ],
            "description": "Desciption"
        }
    ,
        "ncr": {
            "prefix": ["ncr"],
            "body": [
                "fact = [1] * (MAXN + 1)",
				"inv = [1] * (MAXN + 1)",
				"for i in range(2, MAXN + 1):",
				"    fact[i] = fact[i - 1] * i % MOD",
				"inv[MAXN] = pow(fact[MAXN], MOD - 2, MOD)  ",
				"for i in range(MAXN - 1, 0, -1):",
				"    inv[i] = inv[i + 1] * (i + 1) % MOD",
				"def nCr(n, r):",
				"    if r > n or r < 0:",
				"        return 0",
				"    return fact[n] * inv[r] % MOD * inv[n - r] % MOD"

            ],
            "description": "Desciption"
        }
    ,
        "trie": {
            "prefix": ["trie"],
            "body": [
                "class TrieNode:",
				"    def __init__(self):",
				"        self.children = {}",
				"        self.is_end = False",
				"class Trie:",
				"    def __init__(self):",
				"        self.root = TrieNode()",
				"    def insert(self, word):",
				"        node = self.root",
				"        for char in word:",
				"            if char not in node.children:",
				"                node.children[char] = TrieNode()",
				"            node = node.children[char]",
				"        node.is_end = True",
				"    def search(self, word):",
				"        node = self.root",
				"        for char in word:",
				"            if char not in node.children:",
				"                return False",
				"            node = node.children[char]",
				"        return node.is_end",
				"    def starts_with(self, prefix):",
				"        node = self.root",
				"        for char in prefix:",
				"            if char not in node.children:",
				"                return False",
				"            node = node.children[char]",
				"        return True"

            ],
            "description": "Desciption"
        }
    ,
        "lca": {
            "prefix": ["lca"],
            "body": [
                "import math",
				"from collections import deque",
				"",
				"class LCA:",
				"    \"\"\"",
				"    Lowest Common Ancestor using Binary Lifting",
				"    - Build: O(n log n)",
				"    - Query: O(log n)",
				"    \"\"\"",
				"    def __init__(self, n: int, adj: list[list[int]], root: int = 0):",
				"        self.n = n",
				"        self.LOG = max(1, n.bit_length())",
				"        self.depth = [0] * n",
				"        self.parent = [[-1] * n for _ in range(self.LOG)]",
				"        self._build(adj, root)",
				"    ",
				"    def _build(self, adj: list[list[int]], root: int):",
				"        # BFS to set depth and immediate parent",
				"        visited = [False] * self.n",
				"        queue = deque([root])",
				"        visited[root] = True",
				"        self.depth[root] = 0",
				"        self.parent[0][root] = root  # root's parent is itself",
				"        ",
				"        while queue:",
				"            u = queue.popleft()",
				"            for v in adj[u]:",
				"                if not visited[v]:",
				"                    visited[v] = True",
				"                    self.depth[v] = self.depth[u] + 1",
				"                    self.parent[0][v] = u",
				"                    queue.append(v)",
				"        ",
				"        # Build sparse table",
				"        for k in range(1, self.LOG):",
				"            for v in range(self.n):",
				"                if self.parent[k-1][v] != -1:",
				"                    self.parent[k][v] = self.parent[k-1][self.parent[k-1][v]]",
				"    ",
				"    def kth_ancestor(self, u: int, k: int) -> int:",
				"        \"\"\"Returns k-th ancestor of u, or -1 if doesn't exist\"\"\"",
				"        for i in range(self.LOG):",
				"            if k & (1 << i):",
				"                u = self.parent[i][u]",
				"                if u == -1:",
				"                    return -1",
				"        return u",
				"    ",
				"    def lca(self, u: int, v: int) -> int:",
				"        \"\"\"Returns LCA of nodes u and v\"\"\"",
				"        # Make u the deeper node",
				"        if self.depth[u] < self.depth[v]:",
				"            u, v = v, u",
				"        ",
				"        # Bring u to same depth as v",
				"        diff = self.depth[u] - self.depth[v]",
				"        for i in range(self.LOG):",
				"            if diff & (1 << i):",
				"                u = self.parent[i][u]",
				"        ",
				"        if u == v:",
				"            return u",
				"        ",
				"        # Binary search for LCA",
				"        for i in range(self.LOG - 1, -1, -1):",
				"            if self.parent[i][u] != self.parent[i][v]:",
				"                u = self.parent[i][u]",
				"                v = self.parent[i][v]",
				"        ",
				"        return self.parent[0][u]",
				"    ",
				"    def dist(self, u: int, v: int) -> int:",
				"        \"\"\"Returns distance (edges) between u and v\"\"\"",
				"        return self.depth[u] + self.depth[v] - 2 * self.depth[self.lca(u, v)]"

            ],
            "description": "Desciption"
        }
    ,
        "cycledir": {
            "prefix": ["cycledir"],
            "body": [
                "def has_cycle_directed(n, adj):",
				"    WHITE, GRAY, BLACK = 0, 1, 2",
				"    color = [WHITE] * n",
				"    ",
				"    def dfs(u):",
				"        color[u] = GRAY",
				"        for v in adj[u]:",
				"            if color[v] == GRAY:  # Back edge = cycle",
				"                return True",
				"            if color[v] == WHITE and dfs(v):",
				"                return True",
				"        color[u] = BLACK",
				"        return False",
				"    ",
				"    for i in range(n):",
				"        if color[i] == WHITE:",
				"            if dfs(i):",
				"                return True",
				"    return False"

            ],
            "description": "Desciption"
        }
    ,
        "cycleundir": {
            "prefix": ["cycleundir"],
            "body": [
                "def has_cycle_undirected(n, adj):",
				"    visited = [False] * n",
				"    ",
				"    def dfs(u, parent):",
				"        visited[u] = True",
				"        for v in adj[u]:",
				"            if not visited[v]:",
				"                if dfs(v, u):",
				"                    return True",
				"            elif v != parent:  # Visited and not parent = cycle",
				"                return True",
				"        return False",
				"    ",
				"    for i in range(n):",
				"        if not visited[i]:",
				"            if dfs(i, -1):",
				"                return True",
				"    return False"

            ],
            "description": "Desciption"
        }
    ,
        "segment": {
            "prefix": ["segment"],
            "body": [
                "class Segment:",
				"    def __init__(self, a: Point, b: Point):",
				"        self.a = a",
				"        self.b = b",
				"    ",
				"    def contains(self, p: Point) -> bool:",
				"        \"\"\"Check if point is on segment\"\"\"",
				"        return (sign((self.a - p).cross(self.b - p)) == 0 and",
				"                sign((self.a - p).dot(self.b - p)) <= 0)",
				"    ",
				"    def dist(self, p: Point) -> float:",
				"        \"\"\"Distance from point to segment\"\"\"",
				"        if self.a == self.b:",
				"            return p.dist(self.a)",
				"        d = self.b - self.a",
				"        t = max(0.0, min(1.0, (p - self.a).dot(d) / d.norm()))",
				"        return p.dist(self.a + d * t)",
				"    ",
				"    def intersects(self, other: 'Segment') -> bool:",
				"        \"\"\"Check if two segments intersect\"\"\"",
				"        a, b, c, d = self.a, self.b, other.a, other.b",
				"        d1 = Point.ccw(c, d, a)",
				"        d2 = Point.ccw(c, d, b)",
				"        d3 = Point.ccw(a, b, c)",
				"        d4 = Point.ccw(a, b, d)",
				"        ",
				"        if d1 * d2 < 0 and d3 * d4 < 0:",
				"            return True",
				"        if d1 == 0 and other.contains(a): return True",
				"        if d2 == 0 and other.contains(b): return True",
				"        if d3 == 0 and self.contains(c): return True",
				"        if d4 == 0 and self.contains(d): return True",
				"        return False"

            ],
            "description": "Desciption"
        }
    ,
        "circle": {
            "prefix": ["circle"],
            "body": [
                "class Circle:",
				"    def __init__(self, center: Point, radius: float):",
				"        self.c = center",
				"        self.r = radius",
				"    ",
				"    def contains(self, p: Point) -> bool:",
				"        return sign(p.dist(self.c) - self.r) <= 0",
				"    ",
				"    def area(self) -> float:",
				"        return math.pi * self.r * self.r",
				"    ",
				"    def circumference(self) -> float:",
				"        return 2 * math.pi * self.r",
				"    ",
				"    def intersection_area(self, other: 'Circle') -> float:",
				"        d = self.c.dist(other.c)",
				"        if sign(d - self.r - other.r) >= 0:",
				"            return 0.0",
				"        if sign(d + self.r - other.r) <= 0:",
				"            return self.area()",
				"        if sign(d + other.r - self.r) <= 0:",
				"            return other.area()",
				"        ",
				"        a1 = math.acos((self.r**2 + d**2 - other.r**2) / (2 * self.r * d)) * 2",
				"        a2 = math.acos((other.r**2 + d**2 - self.r**2) / (2 * other.r * d)) * 2",
				"        ",
				"        return (self.r**2 * (a1 - math.sin(a1)) + other.r**2 * (a2 - math.sin(a2))) / 2"

            ],
            "description": "Desciption"
        }
    ,
        "line": {
            "prefix": ["line"],
            "body": [
                "class Line:",
				"    def __init__(self, p1: Point, p2: Point):",
				"        self.p1 = p1",
				"        self.p2 = p2",
				"        self.d = p2 - p1",
				"    ",
				"    def side(self, p: Point) -> int:",
				"        \"\"\"1=left, -1=right, 0=on\"\"\"",
				"        return sign(self.d.cross(p - self.p1))",
				"    ",
				"    def dist(self, p: Point) -> float:",
				"        \"\"\"Perpendicular distance from point to line\"\"\"",
				"        return abs(self.d.cross(p - self.p1)) / self.d.abs()",
				"    ",
				"    def project(self, p: Point) -> Point:",
				"        t = (p - self.p1).dot(self.d) / self.d.norm()",
				"        return self.p1 + self.d * t",
				"    ",
				"    def reflect(self, p: Point) -> Point:",
				"        return self.project(p) * 2 - p",
				"    ",
				"    def intersection(self, other: 'Line') -> Point | None:",
				"        cross = self.d.cross(other.d)",
				"        if sign(cross) == 0:",
				"            return None",
				"        t = (other.p1 - self.p1).cross(other.d) / cross",
				"        return self.p1 + self.d * t"

            ],
            "description": "Desciption"
        }
    ,
        "point": {
            "prefix": ["point"],
            "body": [
                "EPS = 1e-9",
				"def sign(x: float) -> int:",
				"    if x > EPS: return 1",
				"    if x < -EPS: return -1",
				"    return 0",
				"",
				"class Point:",
				"    __slots__ = ['x', 'y']",
				"    ",
				"    def __init__(self, x: float = 0, y: float = 0):",
				"        self.x = x",
				"        self.y = y",
				"    ",
				"    def __add__(self, o: 'Point') -> 'Point':",
				"        return Point(self.x + o.x, self.y + o.y)",
				"    ",
				"    def __sub__(self, o: 'Point') -> 'Point':",
				"        return Point(self.x - o.x, self.y - o.y)",
				"    ",
				"    def __mul__(self, k: float) -> 'Point':",
				"        return Point(self.x * k, self.y * k)",
				"    ",
				"    def __truediv__(self, k: float) -> 'Point':",
				"        return Point(self.x / k, self.y / k)",
				"    ",
				"    def __eq__(self, o: 'Point') -> bool: # pyright: ignore",
				"        return sign(self.x - o.x) == 0 and sign(self.y - o.y) == 0",
				"    ",
				"    def __lt__(self, o: 'Point') -> bool:",
				"        return (self.x, self.y) < (o.x, o.y) if sign(self.x - o.x) else self.y < o.y",
				"    ",
				"    def __repr__(self) -> str:",
				"        return f\"({self.x}, {self.y})\"",
				"    ",
				"    def dot(self, o: 'Point') -> float:",
				"        return self.x * o.x + self.y * o.y",
				"    ",
				"    def cross(self, o: 'Point') -> float:",
				"        return self.x * o.y - self.y * o.x",
				"    ",
				"    def norm(self) -> float:",
				"        return self.x * self.x + self.y * self.y",
				"    ",
				"    def abs(self) -> float:",
				"        return math.sqrt(self.norm())",
				"    ",
				"    def unit(self) -> 'Point':",
				"        return self / self.abs()",
				"    ",
				"    def rotate(self, angle: float) -> 'Point':",
				"        c, s = math.cos(angle), math.sin(angle)",
				"        return Point(self.x * c - self.y * s, self.x * s + self.y * c)",
				"    ",
				"    def rotate90(self) -> 'Point':",
				"        return Point(-self.y, self.x)",
				"    ",
				"    def dist(self, o: 'Point') -> float:",
				"        return (self - o).abs()",
				"    ",
				"    def dist_sq(self, o: 'Point') -> float:",
				"        return (self - o).norm()",
				"    ",
				"    @staticmethod",
				"    def ccw(a: 'Point', b: 'Point', c: 'Point') -> int:",
				"        \"\"\"1=ccw, -1=cw, 0=collinear\"\"\"",
				"        return sign((b - a).cross(c - a))"

            ],
            "description": "Desciption"
        }
    ,
        "polygon": {
            "prefix": ["polygon"],
            "body": [
                "class Polygon:",
				"    def __init__(self, pts: list[Point]):",
				"        self.pts = pts",
				"        self.n = len(pts)",
				"    ",
				"    def area(self) -> float:",
				"        \"\"\"Signed area (positive if ccw)\"\"\"",
				"        total = 0.0",
				"        for i in range(self.n):",
				"            total += self.pts[i].cross(self.pts[(i + 1) % self.n])",
				"        return total / 2",
				"    ",
				"    def centroid(self) -> Point:",
				"        a = self.area()",
				"        cx = cy = 0.0",
				"        for i in range(self.n):",
				"            cross = self.pts[i].cross(self.pts[(i + 1) % self.n])",
				"            cx += (self.pts[i].x + self.pts[(i + 1) % self.n].x) * cross",
				"            cy += (self.pts[i].y + self.pts[(i + 1) % self.n].y) * cross",
				"        return Point(cx / (6 * a), cy / (6 * a))",
				"    ",
				"    def contains(self, p: Point) -> int:",
				"        \"\"\"1=inside, 0=boundary, -1=outside\"\"\"",
				"        winding = 0",
				"        for i in range(self.n):",
				"            a, b = self.pts[i], self.pts[(i + 1) % self.n]",
				"            if Segment(a, b).contains(p):",
				"                return 0",
				"            if a.y <= p.y:",
				"                if b.y > p.y and Point.ccw(a, b, p) > 0:",
				"                    winding += 1",
				"            elif b.y <= p.y and Point.ccw(a, b, p) < 0:",
				"                winding -= 1",
				"        return 1 if winding != 0 else -1",
				"    ",
				"    @staticmethod",
				"    def convex_hull(pts: list[Point]) -> 'Polygon':",
				"        \"\"\"Andrew's monotone chain O(n log n)\"\"\"",
				"        pts = sorted(pts)",
				"        if len(pts) <= 1:",
				"            return Polygon(pts)",
				"        ",
				"        lower = []",
				"        for p in pts:",
				"            while len(lower) >= 2 and Point.ccw(lower[-2], lower[-1], p) <= 0:",
				"                lower.pop()",
				"            lower.append(p)",
				"        ",
				"        upper = []",
				"        for p in reversed(pts):",
				"            while len(upper) >= 2 and Point.ccw(upper[-2], upper[-1], p) <= 0:",
				"                upper.pop()",
				"            upper.append(p)",
				"        ",
				"        return Polygon(lower[:-1] + upper[:-1])"

            ],
            "description": "Desciption"
        }
    ,
        "topo": {
            "prefix": ["topo"],
            "body": [
                "def topological_sort(n, adj):",
				"    from collections import deque",
				"    ",
				"    in_degree = [0] * n",
				"    for u in range(n):",
				"        for v in adj[u]:",
				"            in_degree[v] += 1",
				"    ",
				"    queue = deque([i for i in range(n) if in_degree[i] == 0])",
				"    topo_order = []",
				"    ",
				"    while queue:",
				"        u = queue.popleft()",
				"        topo_order.append(u)",
				"        for v in adj[u]:",
				"            in_degree[v] -= 1",
				"            if in_degree[v] == 0:",
				"                queue.append(v)",
				"    ",
				"    return topo_order"

            ],
            "description": "Desciption"
        }
    ,
        "dijkstra": {
            "prefix": ["dijkstra"],
            "body": [
                "from heapq import heappush, heappop",
				"",
				"def dijkstra(",
				"        graph: list[list[tuple[int, int]]] | dict[int, list[tuple[int, int]]],",
				"        start: int",
				") -> list[int | float]:",
				"    \"\"\"",
				"    Single source shortest path for non-negative weights",
				"    graph[u] = [(v, weight), ...]",
				"    Returns dist array from start",
				"    Time: O((V + E) log V)",
				"    \"\"\"",
				"    n = len(graph)",
				"    dist = [float('inf')] * n",
				"    dist[start] = 0",
				"    pq = [(0, start)]",
				"    ",
				"    while pq:",
				"        d, u = heappop(pq)",
				"        if d > dist[u]:",
				"            continue",
				"        for v, w in graph[u]:",
				"            if dist[u] + w < dist[v]:",
				"                dist[v] = dist[u] + w",
				"                heappush(pq, (dist[v], v)) # pyright: ignore",
				"    return dist"

            ],
            "description": "Desciption"
        }
    ,
        "kruskal": {
            "prefix": ["kruskal"],
            "body": [
                "def kruskal(n, edges):",
				"    dsu = DSU(n) # type: ignore # noqa",
				"    ",
				"    # Sort edges by weight",
				"    edges.sort(key=lambda x: x[2])",
				"    ",
				"    total_weight = 0",
				"    mst_edges = []",
				"    ",
				"    for u, v, weight in edges:",
				"        if dsu.find(u) != dsu.find(v):",
				"            dsu.union(u, v)",
				"            total_weight += weight",
				"            mst_edges.append((u, v, weight))",
				"            if len(mst_edges) == n - 1:",
				"                break",
				"    ",
				"    return total_weight, mst_edges"

            ],
            "description": "Desciption"
        }
    ,
        "prim": {
            "prefix": ["prim"],
            "body": [
                "def prim(n, adj):",
				"    import heapq",
				"    ",
				"    visited = [False] * n",
				"    min_heap = [(0, 0, -1)]  # (weight, node, parent)",
				"    total_weight = 0",
				"    edges = []",
				"    ",
				"    while min_heap:",
				"        weight, u, parent = heapq.heappop(min_heap)",
				"        ",
				"        if visited[u]:",
				"            continue",
				"        ",
				"        visited[u] = True",
				"        total_weight += weight",
				"        ",
				"        if parent != -1:",
				"            edges.append((parent, u, weight))",
				"        ",
				"        for v, w in adj[u]:",
				"            if not visited[v]:",
				"                heapq.heappush(min_heap, (w, v, u))",
				"    ",
				"    return total_weight, edges"

            ],
            "description": "Desciption"
        }
    ,
        "zfunc": {
            "prefix": ["zfunc"],
            "body": [
                "def z_function(s: str) -> list[int]:",
				"    \"\"\"",
				"    z[i] = length of longest substring starting at i which is also a prefix",
				"    Time: O(n)",
				"    \"\"\"",
				"    n = len(s)",
				"    z = [0] * n",
				"    z[0] = n",
				"    l = r = 0",
				"    ",
				"    for i in range(1, n):",
				"        if i < r:",
				"            z[i] = min(r - i, z[i - l])",
				"        while i + z[i] < n and s[z[i]] == s[i + z[i]]:",
				"            z[i] += 1",
				"        if i + z[i] > r:",
				"            l, r = i, i + z[i]",
				"    return z",
				"",
				"def z_search(text: str, pattern: str) -> list[int]:",
				"    \"\"\"Find all occurrences of pattern in text using Z-algorithm\"\"\"",
				"    if not pattern:",
				"        return []",
				"    concat = pattern + \"$\" + text",
				"    z = z_function(concat)",
				"    m = len(pattern)",
				"    return [i - m - 1 for i in range(m + 1, len(concat)) if z[i] >= m]"

            ],
            "description": "Desciption"
        }
    ,
        "kmp": {
            "prefix": ["kmp"],
            "body": [
                "def compute_lps(pattern: str) -> list[int]:",
				"    \"\"\"Compute Longest Proper Prefix which is also Suffix array\"\"\"",
				"    m = len(pattern)",
				"    lps = [0] * m",
				"    length = 0",
				"    i = 1",
				"    ",
				"    while i < m:",
				"        if pattern[i] == pattern[length]:",
				"            length += 1",
				"            lps[i] = length",
				"            i += 1",
				"        elif length:",
				"            length = lps[length - 1]",
				"        else:",
				"            lps[i] = 0",
				"            i += 1",
				"    return lps",
				"",
				"def kmp_search(text: str, pattern: str) -> list[int]:",
				"    \"\"\"Returns all starting indices where pattern is found in text\"\"\"",
				"    if not pattern or len(pattern) > len(text):",
				"        return []",
				"    ",
				"    n, m = len(text), len(pattern)",
				"    lps = compute_lps(pattern)",
				"    result = []",
				"    i = j = 0",
				"    ",
				"    while i < n:",
				"        if text[i] == pattern[j]:",
				"            i += 1",
				"            j += 1",
				"        ",
				"        if j == m:",
				"            result.append(i - j)",
				"            j = lps[j - 1]",
				"        elif i < n and text[i] != pattern[j]:",
				"            j = lps[j - 1] if j else 0",
				"            if j == 0 and text[i] != pattern[0]:",
				"                i += 1",
				"    return result"

            ],
            "description": "Desciption"
        }
    ,
        "kosaraju": {
            "prefix": ["kosaraju"],
            "body": [
                "def kosaraju(n, adj):",
				"    # Build reverse graph",
				"    rev_adj = [[] for _ in range(n)]",
				"    for u in range(n):",
				"        for v in adj[u]:",
				"            rev_adj[v].append(u)",
				"    ",
				"    # First DFS to get finish order",
				"    visited = [False] * n",
				"    order = []",
				"    ",
				"    def dfs1(u):",
				"        visited[u] = True",
				"        for v in adj[u]:",
				"            if not visited[v]:",
				"                dfs1(v)",
				"        order.append(u)",
				"    ",
				"    for i in range(n):",
				"        if not visited[i]:",
				"            dfs1(i)",
				"    ",
				"    # Second DFS on reverse graph in reverse finish order",
				"    visited = [False] * n",
				"    sccs = []",
				"    ",
				"    def dfs2(u, scc):",
				"        visited[u] = True",
				"        scc.append(u)",
				"        for v in rev_adj[u]:",
				"            if not visited[v]:",
				"                dfs2(v, scc)",
				"    ",
				"    for u in reversed(order):",
				"        if not visited[u]:",
				"            scc = []",
				"            dfs2(u, scc)",
				"            sccs.append(scc)",
				"    ",
				"    return sccs"

            ],
            "description": "Desciption"
        }
    ,
        "tarjan": {
            "prefix": ["tarjan"],
            "body": [
                "def tarjan(n, adj) -> list[list[int]]:",
				"    disc = [-1] * n",
				"    low = [-1] * n",
				"    on_stack = [False] * n",
				"    stack = []",
				"    time = [0]",
				"    sccs = []",
				"    ",
				"    def dfs(u):",
				"        disc[u] = low[u] = time[0]",
				"        time[0] += 1",
				"        stack.append(u)",
				"        on_stack[u] = True",
				"        ",
				"        for v in adj[u]:",
				"            if disc[v] == -1:",
				"                dfs(v)",
				"                low[u] = min(low[u], low[v])",
				"            elif on_stack[v]:",
				"                low[u] = min(low[u], disc[v])",
				"        ",
				"        if low[u] == disc[u]:",
				"            scc = []",
				"            while True:",
				"                node = stack.pop()",
				"                on_stack[node] = False",
				"                scc.append(node)",
				"                if node == u:",
				"                    break",
				"            sccs.append(scc)",
				"    ",
				"    for i in range(n):",
				"        if disc[i] == -1:",
				"            dfs(i)",
				"    ",
				"    return sccs"

            ],
            "description": "Desciption"
        }
    ,
        "sparse": {
            "prefix": ["sparse"],
            "body": [
                "class SparseTable:",
				"    def __init__(self, array, func=min):",
				"        self.n = len(array)",
				"        self.func = func",
				"        self.k = self.n.bit_length()",
				"        self.st = [[0] * self.n for _ in range(self.k)]",
				"        self.st[0] = array.copy()",
				"        for i in range(1, self.k):",
				"            j = 0",
				"            while j + (1 << i) <= self.n:",
				"                self.st[i][j] = self.func(self.st[i - 1][j], self.st[i - 1][j + (1 << (i - 1))])",
				"                j += 1",
				"",
				"    def query(self, l, r):",
				"        i = (r - l + 1).bit_length() - 1",
				"        return self.func(self.st[i][l], self.st[i][r - (1 << i) + 1])"

            ],
            "description": "Desciption"
        }
    ,
        "ssegt": {
            "prefix": ["ssegt"],
            "body": [
                "tree = [0] * (2 * n)",
				"def query(x, x_low, x_high, q_low, q_high):",
				"    if q_low <= x_low and x_high <= q_high:",
				"        return tree[x]",
				"    if x_high < q_low or q_high < x_low:",
				"        return 0",
				"    mid = (x_low + x_high) // 2",
				"    left = query(x*2, x_low, mid, q_low, q_high)",
				"    right = query(x*2+1, mid+1, x_high, q_low, q_high)",
				"",
				"    return left + right",
				"def update(i, v):",
				"    tree[n+i] = v;",
				"    j = (n + i) // 2",
				"    while j >= 1:",
				"        tree[j] = tree[j*2] + tree[j*2+1]",
				"        j //= 2",
				"    ",
				"for i in range(n):",
				"    tree[n+i] = a[i]",
				"",
				"for i in range(n-1, 0, -1):",
				"    tree[i] = tree[i*2] + tree[i*2+1]"

            ],
            "description": "Desciption"
        }
    ,
        "segt": {
            "prefix": ["segt"],
            "body": [
                "from math import ceil, log2",
				"class segment_tree:",
				"    # merge(left, right): function used to merge the two halves",
				"    # basef(value): function applied on individual values",
				"    # basev: identity for merge function, merger(value, basev) = value",
				"    # update(node_value, old, new): function to update the nodes",
				"    def __init__(self, array, merge=lambda x,y:x+y, basef=lambda x:x, basev = 0):",
				"        self.merge = merge",
				"        self.basef = basef",
				"        self.basev = basev",
				"        self.n = len(array)",
				"        self.array = array",
				"        self.tree = [0] * ( 2**ceil(log2(len(array))+1) - 1 )",
				"        self.build(array)",
				"    def __str__(self):",
				"        return ' '.join([str(x) for x in self.tree])",
				"    def _build_util(self, l, r, i, a):",
				"        if(l==r):",
				"            self.tree[i] = self.basef(a[l])",
				"            return self.tree[i]",
				"        mid = (l+r)//2",
				"        self.tree[i] = self.merge(self._build_util(l,mid, 2*i+1, a), self._build_util(mid+1, r, 2*i+2, a))",
				"        return self.tree[i]",
				"    def build(self, a):",
				"        self._build_util(0, len(a)-1, 0, a)",
				"    def _query_util(self, i, ln, rn, l, r):",
				"        if ln>=l and rn<=r:",
				"            return self.tree[i]",
				"        if ln>r or rn<l:",
				"            return self.basev",
				"        return self.merge( self._query_util( 2*i+1, ln, (ln+rn)//2, l, r ), self._query_util( 2*i+2, (ln+rn)//2+1, rn, l, r ) )",
				"    def query(self, l, r):",
				"        return self._query_util( 0, 0, self.n-1, l, r )",
				"    def _update_util(self, i, ln, rn, x, v):",
				"        if x>=ln and x<=rn:",
				"            if ln != rn:",
				"                self._update_util( 2*i+1, ln, (ln+rn)//2, x, v )",
				"                self._update_util( 2*i+2, (ln+rn)//2 + 1, rn, x, v )",
				"                self.tree[i] = self.merge(self.tree[2*i+1], self.tree[2*i+2])",
				"            else:",
				"                self.tree[i] = self.basef(v)",
				"    def update(self, x, v):",
				"        self._update_util( 0, 0, self.n-1, x, v )   ",
				"        self.array[x] =v"

            ],
            "description": "Desciption"
        }
    ,
        "bit": {
            "prefix": ["bit"],
            "body": [
                "class FenwickTree:",
				"    def __init__(self, size):",
				"        self.n = size",
				"        self.tree = [0] * (self.n + 1)",
				"",
				"    def update(self, idx, delta):",
				"        while idx <= self.n:",
				"            self.tree[idx] += delta",
				"            idx += idx & -idx",
				"",
				"    def query(self, idx):",
				"        res = 0",
				"        while idx > 0:",
				"            res += self.tree[idx]",
				"            idx -= idx & -idx",
				"        return res",
				"",
				"    def range_query(self, l, r):",
				"        return self.query(r) - self.query(l)"

            ],
            "description": "Desciption"
        }
    
}
